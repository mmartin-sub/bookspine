"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from types import TracebackType
from typing import Optional, TYPE_CHECKING, Tuple, Type, Union
from ._doc_common import PdfDocCommon
from ._encryption import PasswordType
from ._utils import StrByteType, StreamType
from .generic import DictionaryObject, IndirectObject, PdfObject
from .xmp import XmpInformation

if TYPE_CHECKING:
    ...
class PdfReader(PdfDocCommon):
    """
    Initialize a PdfReader object.

    This operation can take some time, as the PDF stream's cross-reference
    tables are read into memory.

    Args:
        stream: A File object or an object that supports the standard read
            and seek methods similar to a File object. Could also be a
            string representing a path to a PDF file.
        strict: Determines whether user should be warned of all
            problems and also causes some correctable problems to be fatal.
            Defaults to ``False``.
        password: Decrypt PDF file at initialization. If the
            password is None, the file will not be decrypted.
            Defaults to ``None``.

    """
    def __init__(self, stream: Union[StrByteType, Path], strict: bool = ..., password: Union[None, str, bytes] = ...) -> None:
        ...
    
    def __enter__(self) -> PdfReader:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]) -> None:
        ...
    
    def close(self) -> None:
        """Close the stream if opened in __init__ and clear memory."""
        ...
    
    @property
    def root_object(self) -> DictionaryObject:
        """Provide access to "/Root". Standardized with PdfWriter."""
        ...
    
    @property
    def pdf_header(self) -> str:
        """
        The first 8 bytes of the file.

        This is typically something like ``'%PDF-1.6'`` and can be used to
        detect if the file is actually a PDF file and which version it is.
        """
        ...
    
    @property
    def xmp_metadata(self) -> Optional[XmpInformation]:
        """XMP (Extensible Metadata Platform) data."""
        ...
    
    def get_object(self, indirect_reference: Union[int, IndirectObject]) -> Optional[PdfObject]:
        ...
    
    def read_object_header(self, stream: StreamType) -> Tuple[int, int]:
        ...
    
    def cache_get_indirect_object(self, generation: int, idnum: int) -> Optional[PdfObject]:
        ...
    
    def cache_indirect_object(self, generation: int, idnum: int, obj: Optional[PdfObject]) -> Optional[PdfObject]:
        ...
    
    def read(self, stream: StreamType) -> None:
        """
        Read and process the PDF stream, extracting necessary data.

        Args:
            stream: The PDF file stream.

        """
        ...
    
    def decrypt(self, password: Union[str, bytes]) -> PasswordType:
        """
        When using an encrypted / secured PDF file with the PDF Standard
        encryption handler, this function will allow the file to be decrypted.
        It checks the given password against the document's user password and
        owner password, and then stores the resulting decryption key if either
        password is correct.

        It does not matter which password was matched. Both passwords provide
        the correct decryption key that will allow the document to be used with
        this library.

        Args:
            password: The password to match.

        Returns:
            An indicator if the document was decrypted and whether it was the
            owner password or the user password.

        """
        ...
    
    @property
    def is_encrypted(self) -> bool:
        """
        Read-only boolean property showing whether this PDF file is encrypted.

        Note that this property, if true, will remain true even after the
        :meth:`decrypt()<pypdf.PdfReader.decrypt>` method is called.
        """
        ...
    
    def add_form_topname(self, name: str) -> Optional[DictionaryObject]:
        """
        Add a top level form that groups all form fields below it.

        Args:
            name: text string of the "/T" Attribute of the created object

        Returns:
            The created object. ``None`` means no object was created.

        """
        ...
    
    def rename_form_topname(self, name: str) -> Optional[DictionaryObject]:
        """
        Rename top level form field that all form fields below it.

        Args:
            name: text string of the "/T" field of the created object

        Returns:
            The modified object. ``None`` means no object was modified.

        """
        ...
    


