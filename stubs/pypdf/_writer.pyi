"""
This type stub file was generated by pyright.
"""

import decimal
import enum
from pathlib import Path
from types import TracebackType
from typing import Any, Callable, Dict, IO, Iterable, List, Optional, Pattern, Tuple, Type, Union
from ._doc_common import DocumentInformation, PdfDocCommon
from ._page import PageObject
from ._reader import PdfReader
from ._utils import StrByteType, StreamType
from .constants import FieldDictionaryAttributes as FA, ImageType, PageLabelStyle, UserAccessPermissions
from .generic import ArrayObject, ByteStringObject, Destination, DictionaryObject, EmbeddedFile, Fit, IndirectObject, PdfObject, RectangleObject, TextStringObject, TreeObject, ViewerPreferences
from .pagerange import PageRange, PageRangeSpec
from .types import AnnotationSubtype, LayoutType, OutlineItemType, OutlineType, PagemodeType
from .xmp import XmpInformation

ALL_DOCUMENT_PERMISSIONS = ...
DEFAULT_FONT_HEIGHT_IN_MULTILINE = ...
class ObjectDeletionFlag(enum.IntFlag):
    NONE = ...
    TEXT = ...
    LINKS = ...
    ATTACHMENTS = ...
    OBJECTS_3D = ...
    ALL_ANNOTATIONS = ...
    XOBJECT_IMAGES = ...
    INLINE_IMAGES = ...
    DRAWING_IMAGES = ...
    IMAGES = ...


class PdfWriter(PdfDocCommon):
    """
    Write a PDF file out, given pages produced by another class or through
    cloning a PDF file during initialization.

    Typically data is added from a :class:`PdfReader<pypdf.PdfReader>`.

    Args:
        clone_from: identical to fileobj (for compatibility)

        incremental: If true, loads the document and set the PdfWriter in incremental mode.

            When writing incrementally, the original document is written first and new/modified
            content is appended. To be used for signed document/forms to keep signature valid.

        full: If true, loads all the objects (always full if incremental = True).
            This parameter may allow loading large PDFs.

    """
    def __init__(self, fileobj: Union[None, PdfReader, StrByteType, Path] = ..., clone_from: Union[None, PdfReader, StrByteType, Path] = ..., incremental: bool = ..., full: bool = ...) -> None:
        ...
    
    @property
    def is_encrypted(self) -> bool:
        """
        Read-only boolean property showing whether this PDF file is encrypted.

        Note that this property, if true, will remain true even after the
        :meth:`decrypt()<pypdf.PdfReader.decrypt>` method is called.
        """
        ...
    
    @property
    def root_object(self) -> DictionaryObject:
        """
        Provide direct access to PDF Structure.

        Note:
            Recommended only for read access.

        """
        ...
    
    @property
    def xmp_metadata(self) -> Optional[XmpInformation]:
        """XMP (Extensible Metadata Platform) data."""
        ...
    
    @xmp_metadata.setter
    def xmp_metadata(self, value: Optional[XmpInformation]) -> None:
        """XMP (Extensible Metadata Platform) data."""
        ...
    
    @property
    def with_as_usage(self) -> bool:
        ...
    
    @with_as_usage.setter
    def with_as_usage(self, value: bool) -> None:
        ...
    
    def __enter__(self) -> PdfWriter:
        """Store how writer is initialized by 'with'."""
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], traceback: Optional[TracebackType]) -> None:
        """Write data to the fileobj."""
        ...
    
    @property
    def pdf_header(self) -> str:
        """
        Read/Write property of the PDF header that is written.

        This should be something like ``'%PDF-1.5'``. It is recommended to set
        the lowest version that supports all features which are used within the
        PDF file.

        Note: `pdf_header` returns a string but accepts bytes or str for writing
        """
        ...
    
    @pdf_header.setter
    def pdf_header(self, new_header: Union[str, bytes]) -> None:
        ...
    
    def get_object(self, indirect_reference: Union[int, IndirectObject]) -> PdfObject:
        ...
    
    def set_need_appearances_writer(self, state: bool = ...) -> None:
        """
        Sets the "NeedAppearances" flag in the PDF writer.

        The "NeedAppearances" flag indicates whether the appearance dictionary
        for form fields should be automatically generated by the PDF viewer or
        if the embedded appearance should be used.

        Args:
            state: The actual value of the NeedAppearances flag.

        Returns:
            None

        """
        ...
    
    def create_viewer_preferences(self) -> ViewerPreferences:
        ...
    
    def add_page(self, page: PageObject, excluded_keys: Iterable[str] = ...) -> PageObject:
        """
        Add a page to this PDF file.

        Recommended for advanced usage including the adequate excluded_keys.

        The page is usually acquired from a :class:`PdfReader<pypdf.PdfReader>`
        instance.

        Args:
            page: The page to add to the document. Should be
                an instance of :class:`PageObject<pypdf._page.PageObject>`
            excluded_keys:

        Returns:
            The added PageObject.

        """
        ...
    
    def insert_page(self, page: PageObject, index: int = ..., excluded_keys: Iterable[str] = ...) -> PageObject:
        """
        Insert a page in this PDF file. The page is usually acquired from a
        :class:`PdfReader<pypdf.PdfReader>` instance.

        Args:
            page: The page to add to the document.
            index: Position at which the page will be inserted.
            excluded_keys:

        Returns:
            The added PageObject.

        """
        ...
    
    def add_blank_page(self, width: Optional[float] = ..., height: Optional[float] = ...) -> PageObject:
        """
        Append a blank page to this PDF file and return it.

        If no page size is specified, use the size of the last page.

        Args:
            width: The width of the new page expressed in default user
                space units.
            height: The height of the new page expressed in default
                user space units.

        Returns:
            The newly appended page.

        Raises:
            PageSizeNotDefinedError: if width and height are not defined
                and previous page does not exist.

        """
        ...
    
    def insert_blank_page(self, width: Optional[Union[float, decimal.Decimal]] = ..., height: Optional[Union[float, decimal.Decimal]] = ..., index: int = ...) -> PageObject:
        """
        Insert a blank page to this PDF file and return it.

        If no page size is specified, use the size of the last page.

        Args:
            width: The width of the new page expressed in default user
                space units.
            height: The height of the new page expressed in default
                user space units.
            index: Position to add the page.

        Returns:
            The newly inserted page.

        Raises:
            PageSizeNotDefinedError: if width and height are not defined
                and previous page does not exist.

        """
        ...
    
    @property
    def open_destination(self) -> Union[None, Destination, TextStringObject, ByteStringObject]:
        ...
    
    @open_destination.setter
    def open_destination(self, dest: Union[None, str, Destination, PageObject]) -> None:
        ...
    
    def add_js(self, javascript: str) -> None:
        """
        Add JavaScript which will launch upon opening this PDF.

        Args:
            javascript: Your JavaScript.

        >>> output.add_js("this.print({bUI:true,bSilent:false,bShrinkToFit:true});")
        # Example: This will launch the print window when the PDF is opened.

        """
        ...
    
    def add_attachment(self, filename: str, data: Union[str, bytes]) -> EmbeddedFile:
        """
        Embed a file inside the PDF.

        Reference:
        https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/PDF32000_2008.pdf
        Section 7.11.3

        Args:
            filename: The filename to display.
            data: The data in the file.

        Returns:
            EmbeddedFile instance for the newly created embedded file.

        """
        ...
    
    def append_pages_from_reader(self, reader: PdfReader, after_page_append: Optional[Callable[[PageObject], None]] = ...) -> None:
        """
        Copy pages from reader to writer. Includes an optional callback
        parameter which is invoked after pages are appended to the writer.

        ``append`` should be preferred.

        Args:
            reader: a PdfReader object from which to copy page
                annotations to this writer object. The writer's annots
                will then be updated.
            after_page_append:
                Callback function that is invoked after each page is appended to
                the writer. Signature includes a reference to the appended page
                (delegates to append_pages_from_reader). The single parameter of
                the callback is a reference to the page just appended to the
                document.

        """
        ...
    
    FFBITS_NUL = ...
    def update_page_form_field_values(self, page: Union[PageObject, List[PageObject], None], fields: Dict[str, Union[str, List[str], Tuple[str, str, float]]], flags: FA.FfBits = ..., auto_regenerate: Optional[bool] = ..., flatten: bool = ...) -> None:
        """
        Update the form field values for a given page from a fields dictionary.

        Copy field texts and values from fields to page.
        If the field links to a parent object, add the information to the parent.

        Args:
            page: `PageObject` - references **PDF writer's page** where the
                annotations and field data will be updated.
                `List[Pageobject]` - provides list of pages to be processed.
                `None` - all pages.
            fields: a Python dictionary of:

                * field names (/T) as keys and text values (/V) as value
                * field names (/T) as keys and list of text values (/V) for multiple choice list
                * field names (/T) as keys and tuple of:
                    * text values (/V)
                    * font id (e.g. /F1, the font id must exist)
                    * font size (0 for autosize)

            flags: A set of flags from :class:`~pypdf.constants.FieldDictionaryAttributes.FfBits`.

            auto_regenerate: Set/unset the need_appearances flag;
                the flag is unchanged if auto_regenerate is None.

            flatten: Whether or not to flatten the annotation. If True, this adds the annotation's
                appearance stream to the page contents. Note that this option does not remove the
                annotation itself.

        """
        ...
    
    def reattach_fields(self, page: Optional[PageObject] = ...) -> List[DictionaryObject]:
        """
        Parse annotations within the page looking for orphan fields and
        reattach then into the Fields Structure.

        Args:
            page: page to analyze.
                  If none is provided, all pages will be analyzed.

        Returns:
            list of reattached fields.

        """
        ...
    
    def clone_reader_document_root(self, reader: PdfReader) -> None:
        """
        Copy the reader document root to the writer and all sub-elements,
        including pages, threads, outlines,... For partial insertion, ``append``
        should be considered.

        Args:
            reader: PdfReader from which the document root should be copied.

        """
        ...
    
    def clone_document_from_reader(self, reader: PdfReader, after_page_append: Optional[Callable[[PageObject], None]] = ...) -> None:
        """
        Create a copy (clone) of a document from a PDF file reader cloning
        section '/Root' and '/Info' and '/ID' of the pdf.

        Args:
            reader: PDF file reader instance from which the clone
                should be created.
            after_page_append:
                Callback function that is invoked after each page is appended to
                the writer. Signature includes a reference to the appended page
                (delegates to append_pages_from_reader). The single parameter of
                the callback is a reference to the page just appended to the
                document.

        """
        ...
    
    def generate_file_identifiers(self) -> None:
        """
        Generate an identifier for the PDF that will be written.

        The only point of this is ensuring uniqueness. Reproducibility is not
        required.
        When a file is first written, both identifiers shall be set to the same value.
        If both identifiers match when a file reference is resolved, it is very
        likely that the correct and unchanged file has been found. If only the first
        identifier matches, a different version of the correct file has been found.
        see §14.4 "File Identifiers".
        """
        ...
    
    def encrypt(self, user_password: str, owner_password: Optional[str] = ..., use_128bit: bool = ..., permissions_flag: UserAccessPermissions = ..., *, algorithm: Optional[str] = ...) -> None:
        """
        Encrypt this PDF file with the PDF Standard encryption handler.

        Args:
            user_password: The password which allows for opening
                and reading the PDF file with the restrictions provided.
            owner_password: The password which allows for
                opening the PDF files without any restrictions. By default,
                the owner password is the same as the user password.
            use_128bit: flag as to whether to use 128bit
                encryption. When false, 40bit encryption will be used.
                By default, this flag is on.
            permissions_flag: permissions as described in
                Table 3.20 of the PDF 1.7 specification. A bit value of 1 means
                the permission is granted.
                Hence an integer value of -1 will set all flags.
                Bit position 3 is for printing, 4 is for modifying content,
                5 and 6 control annotations, 9 for form fields,
                10 for extraction of text and graphics.
            algorithm: encrypt algorithm. Values may be one of "RC4-40", "RC4-128",
                "AES-128", "AES-256-R5", "AES-256". If it is valid,
                `use_128bit` will be ignored.

        """
        ...
    
    def write_stream(self, stream: StreamType) -> None:
        ...
    
    def write(self, stream: Union[Path, StrByteType]) -> Tuple[bool, IO[Any]]:
        """
        Write the collection of pages added to this object out as a PDF file.

        Args:
            stream: An object to write the file to. The object can support
                the write method and the tell method, similar to a file object, or
                be a file path, just like the fileobj, just named it stream to keep
                existing workflow.

        Returns:
            A tuple (bool, IO).

        """
        ...
    
    def list_objects_in_increment(self) -> List[IndirectObject]:
        """
        For analysis or debugging.
        Provides the list of new or modified objects that will be written
        in the increment.
        Deleted objects will not be freed but will become orphans.

        Returns:
            List of new or modified IndirectObjects

        """
        ...
    
    @property
    def metadata(self) -> Optional[DocumentInformation]:
        """
        Retrieve/set the PDF file's document information dictionary, if it exists.

        Args:
            value: dict with the entries to be set. if None : remove the /Info entry from the pdf.

        Note that some PDF files use (XMP) metadata streams instead of document
        information dictionaries, and these metadata streams will not be
        accessed by this function, but by :meth:`~xmp_metadata`.

        """
        ...
    
    @metadata.setter
    def metadata(self, value: Optional[Union[DocumentInformation, DictionaryObject, Dict[Any, Any]]]) -> None:
        ...
    
    def add_metadata(self, infos: Dict[str, Any]) -> None:
        """
        Add custom metadata to the output.

        Args:
            infos: a Python dictionary where each key is a field
                and each value is your new metadata.

        """
        ...
    
    def compress_identical_objects(self, remove_identicals: bool = ..., remove_orphans: bool = ...) -> None:
        """
        Parse the PDF file and merge objects that have the same hash.
        This will make objects common to multiple pages.
        Recommended to be used just before writing output.

        Args:
            remove_identicals: Remove identical objects.
            remove_orphans: Remove unreferenced objects.

        """
        ...
    
    def get_reference(self, obj: PdfObject) -> IndirectObject:
        ...
    
    def get_outline_root(self) -> TreeObject:
        ...
    
    def get_threads_root(self) -> ArrayObject:
        """
        The list of threads.

        See §12.4.3 of the PDF 1.7 or PDF 2.0 specification.

        Returns:
            An array (possibly empty) of Dictionaries with an ``/F`` key,
            and optionally information about the thread in ``/I`` or ``/Metadata`` keys.

        """
        ...
    
    @property
    def threads(self) -> ArrayObject:
        """
        Read-only property for the list of threads.

        See §12.4.3 of the PDF 1.7 or PDF 2.0 specification.

        Each element is a dictionary with an ``/F`` key, and optionally
        information about the thread in ``/I`` or ``/Metadata`` keys.
        """
        ...
    
    def add_outline_item_destination(self, page_destination: Union[IndirectObject, PageObject, TreeObject], parent: Union[None, TreeObject, IndirectObject] = ..., before: Union[None, TreeObject, IndirectObject] = ..., is_open: bool = ...) -> IndirectObject:
        ...
    
    def add_outline_item_dict(self, outline_item: OutlineItemType, parent: Union[None, TreeObject, IndirectObject] = ..., before: Union[None, TreeObject, IndirectObject] = ..., is_open: bool = ...) -> IndirectObject:
        ...
    
    def add_outline_item(self, title: str, page_number: Union[None, PageObject, IndirectObject, int], parent: Union[None, TreeObject, IndirectObject] = ..., before: Union[None, TreeObject, IndirectObject] = ..., color: Optional[Union[Tuple[float, float, float], str]] = ..., bold: bool = ..., italic: bool = ..., fit: Fit = ..., is_open: bool = ...) -> IndirectObject:
        """
        Add an outline item (commonly referred to as a "Bookmark") to the PDF file.

        Args:
            title: Title to use for this outline item.
            page_number: Page number this outline item will point to.
            parent: A reference to a parent outline item to create nested
                outline items.
            before:
            color: Color of the outline item's font as a red, green, blue tuple
                from 0.0 to 1.0 or as a Hex String (#RRGGBB)
            bold: Outline item font is bold
            italic: Outline item font is italic
            fit: The fit of the destination page.

        Returns:
            The added outline item as an indirect object.

        """
        ...
    
    def add_outline(self) -> None:
        ...
    
    def add_named_destination_array(self, title: TextStringObject, destination: Union[IndirectObject, ArrayObject]) -> None:
        ...
    
    def add_named_destination_object(self, page_destination: PdfObject) -> IndirectObject:
        ...
    
    def add_named_destination(self, title: str, page_number: int) -> IndirectObject:
        ...
    
    def remove_links(self) -> None:
        """Remove links and annotations from this output."""
        ...
    
    def remove_annotations(self, subtypes: Optional[Union[AnnotationSubtype, Iterable[AnnotationSubtype]]]) -> None:
        """
        Remove annotations by annotation subtype.

        Args:
            subtypes: subtype or list of subtypes to be removed.
                Examples are: "/Link", "/FileAttachment", "/Sound",
                "/Movie", "/Screen", ...
                If you want to remove all annotations, use subtypes=None.

        """
        ...
    
    def remove_objects_from_page(self, page: Union[PageObject, DictionaryObject], to_delete: Union[ObjectDeletionFlag, Iterable[ObjectDeletionFlag]], text_filters: Optional[Dict[str, Any]] = ...) -> None:
        """
        Remove objects specified by ``to_delete`` from the given page.

        Args:
            page: Page object to clean up.
            to_delete: Objects to be deleted; can be a ``ObjectDeletionFlag``
                or a list of ObjectDeletionFlag
            text_filters: Properties of text to be deleted, if applicable. Optional.
                This is a Python dictionary with the following properties:

                * font_ids: List of font resource IDs (such as /F1 or /T1_0) to be deleted.

        """
        ...
    
    def remove_images(self, to_delete: ImageType = ...) -> None:
        """
        Remove images from this output.

        Args:
            to_delete: The type of images to be deleted
                (default = all images types)

        """
        ...
    
    def remove_text(self, font_names: Optional[List[str]] = ...) -> None:
        """
        Remove text from the PDF.

        Args:
            font_names: List of font names to remove, such as "Helvetica-Bold".
                Optional. If not specified, all text will be removed.
        """
        ...
    
    def add_uri(self, page_number: int, uri: str, rect: RectangleObject, border: Optional[ArrayObject] = ...) -> None:
        """
        Add an URI from a rectangular area to the specified page.

        Args:
            page_number: index of the page on which to place the URI action.
            uri: URI of resource to link to.
            rect: :class:`RectangleObject<pypdf.generic.RectangleObject>` or
                array of four integers specifying the clickable rectangular area
                ``[xLL, yLL, xUR, yUR]``, or string in the form
                ``"[ xLL yLL xUR yUR ]"``.
            border: if provided, an array describing border-drawing
                properties. See the PDF spec for details. No border will be
                drawn if this argument is omitted.

        """
        ...
    
    _valid_layouts = ...
    def set_page_layout(self, layout: LayoutType) -> None:
        """
        Set the page layout.

        Args:
            layout: The page layout to be used

        .. list-table:: Valid ``layout`` arguments
           :widths: 50 200

           * - /NoLayout
             - Layout explicitly not specified
           * - /SinglePage
             - Show one page at a time
           * - /OneColumn
             - Show one column at a time
           * - /TwoColumnLeft
             - Show pages in two columns, odd-numbered pages on the left
           * - /TwoColumnRight
             - Show pages in two columns, odd-numbered pages on the right
           * - /TwoPageLeft
             - Show two pages at a time, odd-numbered pages on the left
           * - /TwoPageRight
             - Show two pages at a time, odd-numbered pages on the right

        """
        ...
    
    @property
    def page_layout(self) -> Optional[LayoutType]:
        """
        Page layout property.

        .. list-table:: Valid ``layout`` values
           :widths: 50 200

           * - /NoLayout
             - Layout explicitly not specified
           * - /SinglePage
             - Show one page at a time
           * - /OneColumn
             - Show one column at a time
           * - /TwoColumnLeft
             - Show pages in two columns, odd-numbered pages on the left
           * - /TwoColumnRight
             - Show pages in two columns, odd-numbered pages on the right
           * - /TwoPageLeft
             - Show two pages at a time, odd-numbered pages on the left
           * - /TwoPageRight
             - Show two pages at a time, odd-numbered pages on the right
        """
        ...
    
    @page_layout.setter
    def page_layout(self, layout: LayoutType) -> None:
        ...
    
    _valid_modes = ...
    @property
    def page_mode(self) -> Optional[PagemodeType]:
        """
        Page mode property.

        .. list-table:: Valid ``mode`` values
           :widths: 50 200

           * - /UseNone
             - Do not show outline or thumbnails panels
           * - /UseOutlines
             - Show outline (aka bookmarks) panel
           * - /UseThumbs
             - Show page thumbnails panel
           * - /FullScreen
             - Fullscreen view
           * - /UseOC
             - Show Optional Content Group (OCG) panel
           * - /UseAttachments
             - Show attachments panel
        """
        ...
    
    @page_mode.setter
    def page_mode(self, mode: PagemodeType) -> None:
        ...
    
    def add_annotation(self, page_number: Union[int, PageObject], annotation: Dict[str, Any]) -> DictionaryObject:
        """
        Add a single annotation to the page.
        The added annotation must be a new annotation.
        It cannot be recycled.

        Args:
            page_number: PageObject or page index.
            annotation: Annotation to be added (created with annotation).

        Returns:
            The inserted object.
            This can be used for popup creation, for example.

        """
        ...
    
    def clean_page(self, page: Union[PageObject, IndirectObject]) -> PageObject:
        """
        Perform some clean up in the page.
        Currently: convert NameObject named destination to TextStringObject
        (required for names/dests list)

        Args:
            page:

        Returns:
            The cleaned PageObject

        """
        ...
    
    def append(self, fileobj: Union[StrByteType, PdfReader, Path], outline_item: Union[str, None, PageRange, Tuple[int, int], Tuple[int, int, int], List[int]] = ..., pages: Union[None, PageRange, Tuple[int, int], Tuple[int, int, int], List[int], List[PageObject],] = ..., import_outline: bool = ..., excluded_fields: Optional[Union[List[str], Tuple[str, ...]]] = ...) -> None:
        """
        Identical to the :meth:`merge()<merge>` method, but assumes you want to
        concatenate all pages onto the end of the file instead of specifying a
        position.

        Args:
            fileobj: A File Object or an object that supports the standard
                read and seek methods similar to a File Object. Could also be a
                string representing a path to a PDF file.
            outline_item: Optionally, you may specify a string to build an
                outline (aka 'bookmark') to identify the beginning of the
                included file.
            pages: Can be a :class:`PageRange<pypdf.pagerange.PageRange>`
                or a ``(start, stop[, step])`` tuple
                or a list of pages to be processed
                to merge only the specified range of pages from the source
                document into the output document.
            import_outline: You may prevent the source document's
                outline (collection of outline items, previously referred to as
                'bookmarks') from being imported by specifying this as ``False``.
            excluded_fields: Provide the list of fields/keys to be ignored
                if ``/Annots`` is part of the list, the annotation will be ignored
                if ``/B`` is part of the list, the articles will be ignored

        """
        ...
    
    def merge(self, position: Optional[int], fileobj: Union[Path, StrByteType, PdfReader], outline_item: Optional[str] = ..., pages: Optional[Union[PageRangeSpec, List[PageObject]]] = ..., import_outline: bool = ..., excluded_fields: Optional[Union[List[str], Tuple[str, ...]]] = ...) -> None:
        """
        Merge the pages from the given file into the output file at the
        specified page number.

        Args:
            position: The *page number* to insert this file. File will
                be inserted after the given number.
            fileobj: A File Object or an object that supports the standard
                read and seek methods similar to a File Object. Could also be a
                string representing a path to a PDF file.
            outline_item: Optionally, you may specify a string to build an outline
                (aka 'bookmark') to identify the
                beginning of the included file.
            pages: can be a :class:`PageRange<pypdf.pagerange.PageRange>`
                or a ``(start, stop[, step])`` tuple
                or a list of pages to be processed
                to merge only the specified range of pages from the source
                document into the output document.
            import_outline: You may prevent the source document's
                outline (collection of outline items, previously referred to as
                'bookmarks') from being imported by specifying this as ``False``.
            excluded_fields: provide the list of fields/keys to be ignored
                if ``/Annots`` is part of the list, the annotation will be ignored
                if ``/B`` is part of the list, the articles will be ignored

        Raises:
            TypeError: The pages attribute is not configured properly

        """
        ...
    
    def add_filtered_articles(self, fltr: Union[Pattern[Any], str], pages: Dict[int, PageObject], reader: PdfReader) -> None:
        """
        Add articles matching the defined criteria.

        Args:
            fltr:
            pages:
            reader:

        """
        ...
    
    def close(self) -> None:
        """Implemented for API harmonization."""
        ...
    
    def find_outline_item(self, outline_item: Dict[str, Any], root: Optional[OutlineType] = ...) -> Optional[List[int]]:
        ...
    
    def find_bookmark(self, outline_item: Dict[str, Any], root: Optional[OutlineType] = ...) -> None:
        """
        .. deprecated:: 2.9.0
            Use :meth:`find_outline_item` instead.
        """
        ...
    
    def reset_translation(self, reader: Union[None, PdfReader, IndirectObject] = ...) -> None:
        """
        Reset the translation table between reader and the writer object.

        Late cloning will create new independent objects.

        Args:
            reader: PdfReader or IndirectObject referencing a PdfReader object.
                if set to None or omitted, all tables will be reset.

        """
        ...
    
    def set_page_label(self, page_index_from: int, page_index_to: int, style: Optional[PageLabelStyle] = ..., prefix: Optional[str] = ..., start: Optional[int] = ...) -> None:
        """
        Set a page label to a range of pages.

        Page indexes must be given starting from 0.
        Labels must have a style, a prefix or both.
        If a range is not assigned any page label, a decimal label starting from 1 is applied.

        Args:
            page_index_from: page index of the beginning of the range starting from 0
            page_index_to: page index of the beginning of the range starting from 0
            style: The numbering style to be used for the numeric portion of each page label:

                       * ``/D`` Decimal Arabic numerals
                       * ``/R`` Uppercase Roman numerals
                       * ``/r`` Lowercase Roman numerals
                       * ``/A`` Uppercase letters (A to Z for the first 26 pages,
                         AA to ZZ for the next 26, and so on)
                       * ``/a`` Lowercase letters (a to z for the first 26 pages,
                         aa to zz for the next 26, and so on)

            prefix: The label prefix for page labels in this range.
            start:  The value of the numeric portion for the first page label
                    in the range.
                    Subsequent pages are numbered sequentially from this value,
                    which must be greater than or equal to 1.
                    Default value: 1.

        """
        ...
    


def generate_appearance_stream(txt: str, sel: List[str], da: str, font_full_rev: Dict[str, bytes], rct: RectangleObject, font_height: float, y_offset: float) -> bytes:
    ...

