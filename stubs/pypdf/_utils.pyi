"""
This type stub file was generated by pyright.
"""

import functools
import sys
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, IO, Optional, Pattern, Self, Tuple, TypeAlias, Union, overload
from typing_extensions import TypeAlias

"""Utility functions for PDF library."""
__author__ = ...
__author_email__ = ...
if sys.version_info[: 2] >= (3, 10):
    ...
else:
    ...
if sys.version_info >= (3, 11):
    ...
else:
    ...
TransformationMatrixType: TypeAlias = Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]
CompressedTransformationMatrix: TypeAlias = Tuple[float, float, float, float, float, float]
StreamType = IO[Any]
StrByteType = Union[str, StreamType]
def parse_iso8824_date(text: Optional[str]) -> Optional[datetime]:
    ...

def format_iso8824_date(dt: datetime) -> str:
    """
    Convert a datetime object to PDF date string format.

    Converts datetime to the PDF date format D:YYYYMMDDHHmmSSOHH'mm
    as specified in the PDF Reference.

    Args:
        dt: A datetime object to convert.

    Returns:
        A date string in PDF format.
    """
    ...

WHITESPACES = ...
WHITESPACES_AS_BYTES = ...
WHITESPACES_AS_REGEXP = ...
def read_until_whitespace(stream: StreamType, maxchars: Optional[int] = ...) -> bytes:
    """
    Read non-whitespace characters and return them.

    Stops upon encountering whitespace or when maxchars is reached.

    Args:
        stream: The data stream from which was read.
        maxchars: The maximum number of bytes returned; by default unlimited.

    Returns:
        The data which was read.

    """
    ...

def read_non_whitespace(stream: StreamType) -> bytes:
    """
    Find and read the next non-whitespace character (ignores whitespace).

    Args:
        stream: The data stream from which was read.

    Returns:
        The data which was read.

    """
    ...

def skip_over_whitespace(stream: StreamType) -> bool:
    """
    Similar to read_non_whitespace, but return a boolean if at least one
    whitespace character was read.

    Args:
        stream: The data stream from which was read.

    Returns:
        True if one or more whitespace was skipped, otherwise return False.

    """
    ...

def check_if_whitespace_only(value: bytes) -> bool:
    """
    Check if the given value consists of whitespace characters only.

    Args:
        value: The bytes to check.

    Returns:
        True if the value only has whitespace characters, otherwise return False.

    """
    ...

def skip_over_comment(stream: StreamType) -> None:
    ...

def read_until_regex(stream: StreamType, regex: Pattern[bytes]) -> bytes:
    """
    Read until the regular expression pattern matched (ignore the match).
    Treats EOF on the underlying stream as the end of the token to be matched.

    Args:
        regex: re.Pattern

    Returns:
        The read bytes.

    """
    ...

def read_block_backwards(stream: StreamType, to_read: int) -> bytes:
    """
    Given a stream at position X, read a block of size to_read ending at position X.

    This changes the stream's position to the beginning of where the block was
    read.

    Args:
        stream:
        to_read:

    Returns:
        The data which was read.

    """
    ...

def read_previous_line(stream: StreamType) -> bytes:
    """
    Given a byte stream with current position X, return the previous line.

    All characters between the first CR/LF byte found before X
    (or, the start of the file, if no such byte is found) and position X
    After this call, the stream will be positioned one byte after the
    first non-CRLF character found beyond the first CR/LF byte before X,
    or, if no such byte is found, at the beginning of the stream.

    Args:
        stream: StreamType:

    Returns:
        The data which was read.

    """
    ...

def matrix_multiply(a: TransformationMatrixType, b: TransformationMatrixType) -> TransformationMatrixType:
    ...

def mark_location(stream: StreamType) -> None:
    """Create text file showing current location in context."""
    ...

@overload
def ord_(b: str) -> int:
    ...

@overload
def ord_(b: bytes) -> bytes:
    ...

@overload
def ord_(b: int) -> int:
    ...

def ord_(b: Union[int, str, bytes]) -> Union[int, bytes]:
    ...

def deprecate(msg: str, stacklevel: int = ...) -> None:
    ...

def deprecation(msg: str) -> None:
    ...

def deprecate_with_replacement(old_name: str, new_name: str, removed_in: str) -> None:
    """Issue a warning that a feature will be removed, but has a replacement."""
    ...

def deprecation_with_replacement(old_name: str, new_name: str, removed_in: str) -> None:
    """Raise an exception that a feature was already removed, but has a replacement."""
    ...

def deprecate_no_replacement(name: str, removed_in: str) -> None:
    """Issue a warning that a feature will be removed without replacement."""
    ...

def deprecation_no_replacement(name: str, removed_in: str) -> None:
    """Raise an exception that a feature was already removed without replacement."""
    ...

def logger_error(msg: str, src: str) -> None:
    """
    Use this instead of logger.error directly.

    That allows people to overwrite it more easily.

    See the docs on when to use which:
    https://pypdf.readthedocs.io/en/latest/user/suppress-warnings.html
    """
    ...

def logger_warning(msg: str, src: str) -> None:
    """
    Use this instead of logger.warning directly.

    That allows people to overwrite it more easily.

    ## Exception, warnings.warn, logger_warning
    - Exceptions should be used if the user should write code that deals with
      an error case, e.g. the PDF being completely broken.
    - warnings.warn should be used if the user needs to fix their code, e.g.
      DeprecationWarnings
    - logger_warning should be used if the user needs to know that an issue was
      handled by pypdf, e.g. a non-compliant PDF being read in a way that
      pypdf could apply a robustness fix to still read it. This applies mainly
      to strict=False mode.
    """
    ...

def rename_kwargs(func_name: str, kwargs: Dict[str, Any], aliases: Dict[str, str], fail: bool = ...) -> None:
    """
    Helper function to deprecate arguments.

    Args:
        func_name: Name of the function to be deprecated
        kwargs:
        aliases:
        fail:

    """
    ...

class classproperty:
    """
    Decorator that converts a method with a single cls argument into a property
    that can be accessed directly from the class.
    """
    def __init__(self, method=...) -> None:
        ...

    def __get__(self, instance, cls=...) -> Any:
        ...

    def getter(self, method) -> Self:
        ...



@dataclass
class File:
    name: str = ...
    data: bytes = ...
    indirect_reference: Optional[IndirectObject] = ...
    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...



@functools.total_ordering
class Version:
    COMPONENT_PATTERN = ...
    def __init__(self, version_str: str) -> None:
        ...

    def __eq__(self, other: object) -> bool:
        ...

    def __hash__(self) -> int:
        ...

    def __lt__(self, other: Any) -> bool:
        ...
