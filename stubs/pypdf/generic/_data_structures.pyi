"""
This type stub file was generated by pyright.
"""

import sys
from typing import Any, Callable, Dict, Iterable, List, Optional, Self, Sequence, Tuple, Union
from .._protocols import PdfReaderProtocol, PdfWriterProtocol, XmpInformationProtocol
from .._utils import StreamType
from ..constants import OutlineFontFlag
from ._base import FloatObject, IndirectObject, NameObject, NullObject, NumberObject, PdfObject
from ._fit import Fit

__author__ = ...
__author_email__ = ...
if sys.version_info >= (3, 11):
    ...
else:
    ...
logger = ...
IndirectPattern = ...
class ArrayObject(List[Any], PdfObject):
    def replicate(self, pdf_dest: PdfWriterProtocol) -> ArrayObject:
        ...

    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> ArrayObject:
        """Clone object into pdf_dest."""
        ...

    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...

    def items(self) -> Iterable[Any]:
        """Emulate DictionaryObject.items for a list (index, object)."""
        ...

    def __add__(self, lst: Any) -> ArrayObject:
        """
        Allow extension by adding list or add one element only

        Args:
            lst: any list, tuples are extended the list.
            other types(numbers,...) will be appended.
            if str is passed it will be converted into TextStringObject
            or NameObject (if starting with "/")
            if bytes is passed it will be converted into ByteStringObject

        Returns:
            ArrayObject with all elements

        """
        ...

    def __iadd__(self, lst: Any) -> Self:
        """
         Allow extension by adding list or add one element only

        Args:
            lst: any list, tuples are extended the list.
            other types(numbers,...) will be appended.
            if str is passed it will be converted into TextStringObject
            or NameObject (if starting with "/")
            if bytes is passed it will be converted into ByteStringObject

        """
        ...

    def __isub__(self, lst: Any) -> Self:
        """Allow to remove items"""
        ...

    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...

    @staticmethod
    def read_from_stream(stream: StreamType, pdf: Optional[PdfReaderProtocol], forced_encoding: Union[None, str, List[str], Dict[int, str]] = ...) -> ArrayObject:
        ...



class DictionaryObject(Dict[Any, Any], PdfObject):
    def replicate(self, pdf_dest: PdfWriterProtocol) -> DictionaryObject:
        ...

    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> DictionaryObject:
        """Clone object into pdf_dest."""
        ...

    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...

    def raw_get(self, key: Any) -> Any:
        ...

    def get_inherited(self, key: str, default: Any = ...) -> Any:
        """
        Returns the value of a key or from the parent if not found.
        If not found returns default.

        Args:
            key: string identifying the field to return

            default: default value to return

        Returns:
            Current key or inherited one, otherwise default value.

        """
        ...

    def __setitem__(self, key: Any, value: Any) -> Any:
        ...

    def setdefault(self, key: Any, value: Optional[Any] = ...) -> Any:
        ...

    def __getitem__(self, key: Any) -> PdfObject:
        ...

    @property
    def xmp_metadata(self) -> Optional[XmpInformationProtocol]:
        """
        Retrieve XMP (Extensible Metadata Platform) data relevant to this
        object, if available.

        See Table 347 â€” Additional entries in a metadata stream dictionary.

        Returns:
          Returns a :class:`~pypdf.xmp.XmpInformation` instance
          that can be used to access XMP metadata from the document. Can also
          return None if no metadata was found on the document root.

        """
        ...

    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...

    @staticmethod
    def read_from_stream(stream: StreamType, pdf: Optional[PdfReaderProtocol], forced_encoding: Union[None, str, List[str], Dict[int, str]] = ...) -> DictionaryObject:
        ...



class TreeObject(DictionaryObject):
    def __init__(self, dct: Optional[DictionaryObject] = ...) -> None:
        ...

    def has_children(self) -> bool:
        ...

    def __iter__(self) -> Any:
        ...

    def children(self) -> Iterable[Any]:
        ...

    def add_child(self, child: Any, pdf: PdfWriterProtocol) -> None:
        ...

    def inc_parent_counter_default(self, parent: Union[None, IndirectObject, TreeObject], n: int) -> None:
        ...

    def inc_parent_counter_outline(self, parent: Union[None, IndirectObject, TreeObject], n: int) -> None:
        ...

    def insert_child(self, child: Any, before: Any, pdf: PdfWriterProtocol, inc_parent_counter: Optional[Callable[..., Any]] = ...) -> IndirectObject:
        ...

    def remove_child(self, child: Any) -> None:
        ...

    def remove_from_tree(self) -> None:
        """Remove the object from the tree it is in."""
        ...

    def empty_tree(self) -> None:
        ...



class StreamObject(DictionaryObject):
    def __init__(self) -> None:
        ...

    def replicate(self, pdf_dest: PdfWriterProtocol) -> StreamObject:
        ...

    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...

    def get_data(self) -> bytes:
        ...

    def set_data(self, data: bytes) -> None:
        ...

    def hash_value_data(self) -> bytes:
        ...

    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...

    @staticmethod
    def initializeFromDictionary(data: Dict[str, Any]) -> None:
        ...

    @staticmethod
    def initialize_from_dictionary(data: Dict[str, Any]) -> Union[EncodedStreamObject, DecodedStreamObject]:
        ...

    def flate_encode(self, level: int = ...) -> EncodedStreamObject:
        ...

    def decode_as_image(self) -> Any:
        """
        Try to decode the stream object as an image

        Returns:
            a PIL image if proper decoding has been found
        Raises:
            Exception: (any)during decoding to to invalid object or
                errors during decoding will be reported
                It is recommended to catch exceptions to prevent
                stops in your program.

        """
        ...



class DecodedStreamObject(StreamObject):
    ...


class EncodedStreamObject(StreamObject):
    def __init__(self) -> None:
        ...

    def get_data(self) -> bytes:
        ...

    def set_data(self, data: bytes) -> None:
        ...



class ContentStream(DecodedStreamObject):
    """
    In order to be fast, this data structure can contain either:

    * raw data in ._data
    * parsed stream operations in ._operations.

    At any time, ContentStream object can either have both of those fields defined,
    or one field defined and the other set to None.

    These fields are "rebuilt" lazily, when accessed:

    * when .get_data() is called, if ._data is None, it is rebuilt from ._operations.
    * when .operations is called, if ._operations is None, it is rebuilt from ._data.

    Conversely, these fields can be invalidated:

    * when .set_data() is called, ._operations is set to None.
    * when .operations is set, ._data is set to None.
    """
    def __init__(self, stream: Any, pdf: Any, forced_encoding: Union[None, str, List[str], Dict[int, str]] = ...) -> None:
        ...

    def replicate(self, pdf_dest: PdfWriterProtocol) -> ContentStream:
        ...

    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> ContentStream:
        """
        Clone object into pdf_dest.

        Args:
            pdf_dest:
            force_duplicate:
            ignore_fields:

        Returns:
            The cloned ContentStream

        """
        ...

    def get_data(self) -> bytes:
        ...

    def set_data(self, data: bytes) -> None:
        ...

    @property
    def operations(self) -> List[Tuple[Any, bytes]]:
        ...

    @operations.setter
    def operations(self, operations: List[Tuple[Any, bytes]]) -> None:
        ...

    def isolate_graphics_state(self) -> None:
        ...

    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...



def read_object(stream: StreamType, pdf: Optional[PdfReaderProtocol], forced_encoding: Union[None, str, List[str], Dict[int, str]] = ...) -> Union[PdfObject, int, str, ContentStream]:
    ...

class Field(TreeObject):
    """
    A class representing a field dictionary.

    This class is accessed through
    :meth:`get_fields()<pypdf.PdfReader.get_fields>`
    """
    def __init__(self, data: DictionaryObject) -> None:
        ...

    @property
    def field_type(self) -> Optional[NameObject]:
        """Read-only property accessing the type of this field."""
        ...

    @property
    def parent(self) -> Optional[DictionaryObject]:
        """Read-only property accessing the parent of this field."""
        ...

    @property
    def kids(self) -> Optional[ArrayObject]:
        """Read-only property accessing the kids of this field."""
        ...

    @property
    def name(self) -> Optional[str]:
        """Read-only property accessing the name of this field."""
        ...

    @property
    def alternate_name(self) -> Optional[str]:
        """Read-only property accessing the alternate name of this field."""
        ...

    @property
    def mapping_name(self) -> Optional[str]:
        """
        Read-only property accessing the mapping name of this field.

        This name is used by pypdf as a key in the dictionary returned by
        :meth:`get_fields()<pypdf.PdfReader.get_fields>`
        """
        ...

    @property
    def flags(self) -> Optional[int]:
        """
        Read-only property accessing the field flags, specifying various
        characteristics of the field (see Table 8.70 of the PDF 1.7 reference).
        """
        ...

    @property
    def value(self) -> Optional[Any]:
        """
        Read-only property accessing the value of this field.

        Format varies based on field type.
        """
        ...

    @property
    def default_value(self) -> Optional[Any]:
        """Read-only property accessing the default value of this field."""
        ...

    @property
    def additional_actions(self) -> Optional[DictionaryObject]:
        """
        Read-only property accessing the additional actions dictionary.

        This dictionary defines the field's behavior in response to trigger
        events. See Section 8.5.2 of the PDF 1.7 reference.
        """
        ...



class Destination(TreeObject):
    """
    A class representing a destination within a PDF file.

    See section 12.3.2 of the PDF 2.0 reference.

    Args:
        title: Title of this destination.
        page: Reference to the page of this destination. Should
            be an instance of :class:`IndirectObject<pypdf.generic.IndirectObject>`.
        fit: How the destination is displayed.

    Raises:
        PdfReadError: If destination type is invalid.

    """
    node: Optional[DictionaryObject] = ...
    def __init__(self, title: str, page: Union[NumberObject, IndirectObject, NullObject, DictionaryObject], fit: Fit) -> None:
        ...

    @property
    def dest_array(self) -> ArrayObject:
        ...

    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...

    @property
    def title(self) -> Optional[str]:
        """Read-only property accessing the destination title."""
        ...

    @property
    def page(self) -> Optional[IndirectObject]:
        """Read-only property accessing the IndirectObject of the destination page."""
        ...

    @property
    def typ(self) -> Optional[str]:
        """Read-only property accessing the destination type."""
        ...

    @property
    def zoom(self) -> Optional[int]:
        """Read-only property accessing the zoom factor."""
        ...

    @property
    def left(self) -> Optional[FloatObject]:
        """Read-only property accessing the left horizontal coordinate."""
        ...

    @property
    def right(self) -> Optional[FloatObject]:
        """Read-only property accessing the right horizontal coordinate."""
        ...

    @property
    def top(self) -> Optional[FloatObject]:
        """Read-only property accessing the top vertical coordinate."""
        ...

    @property
    def bottom(self) -> Optional[FloatObject]:
        """Read-only property accessing the bottom vertical coordinate."""
        ...

    @property
    def color(self) -> Optional[ArrayObject]:
        """Read-only property accessing the color in (R, G, B) with values 0.0-1.0."""
        ...

    @property
    def font_format(self) -> Optional[OutlineFontFlag]:
        """
        Read-only property accessing the font type.

        1=italic, 2=bold, 3=both
        """
        ...

    @property
    def outline_count(self) -> Optional[int]:
        """
        Read-only property accessing the outline count.

        positive = expanded
        negative = collapsed
        absolute value = number of visible descendants at all levels
        """
        ...
