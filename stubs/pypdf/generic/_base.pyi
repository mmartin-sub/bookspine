"""
This type stub file was generated by pyright.
"""

import hashlib
import sys
from typing import Any, Callable, ClassVar, Dict, Optional, Sequence, TypeGuard, Union
from typing_extensions import TypeGuard
from .._protocols import PdfObjectProtocol, PdfWriterProtocol
from .._utils import StreamType, classproperty

if sys.version_info[: 2] >= (3, 10):
    ...
else:
    ...
__author__ = ...
__author_email__ = ...
class PdfObject(PdfObjectProtocol):
    hash_func: Callable[..., hashlib._Hash] = ...
    indirect_reference: Optional[IndirectObject]
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def hash_value_data(self) -> bytes:
        ...
    
    def hash_value(self) -> bytes:
        ...
    
    def replicate(self, pdf_dest: PdfWriterProtocol) -> PdfObject:
        """
        Clone object into pdf_dest (PdfWriterProtocol which is an interface for PdfWriter)
        without ensuring links. This is used in clone_document_from_root with incremental = True.

        Args:
          pdf_dest: Target to clone to.

        Returns:
          The cloned PdfObject

        """
        ...
    
    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> PdfObject:
        """
        Clone object into pdf_dest (PdfWriterProtocol which is an interface for PdfWriter).

        By default, this method will call ``_reference_clone`` (see ``_reference``).


        Args:
          pdf_dest: Target to clone to.
          force_duplicate: By default, if the object has already been cloned and referenced,
            the copy will be returned; when ``True``, a new copy will be created.
            (Default value = ``False``)
          ignore_fields: List/tuple of field names (for dictionaries) that will be ignored
            during cloning (applies to children duplication as well). If fields are to be
            considered for a limited number of levels, you have to add it as integer, for
            example ``[1,"/B","/TOTO"]`` means that ``"/B"`` will be ignored at the first
            level only but ``"/TOTO"`` on all levels.

        Returns:
          The cloned PdfObject

        """
        ...
    
    def get_object(self) -> Optional[PdfObject]:
        """Resolve indirect references."""
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    


class NullObject(PdfObject):
    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> NullObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    @staticmethod
    def read_from_stream(stream: StreamType) -> NullObject:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class BooleanObject(PdfObject):
    def __init__(self, value: Any) -> None:
        ...
    
    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> BooleanObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def __eq__(self, o: object, /) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    @staticmethod
    def read_from_stream(stream: StreamType) -> BooleanObject:
        ...
    


class IndirectObject(PdfObject):
    def __init__(self, idnum: int, generation: int, pdf: Any) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def replicate(self, pdf_dest: PdfWriterProtocol) -> PdfObject:
        ...
    
    def clone(self, pdf_dest: PdfWriterProtocol, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> IndirectObject:
        """Clone object into pdf_dest."""
        ...
    
    @property
    def indirect_reference(self) -> IndirectObject:
        ...
    
    def get_object(self) -> Optional[PdfObject]:
        ...
    
    def __deepcopy__(self, memo: Any) -> IndirectObject:
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    
    def __getitem__(self, key: Any) -> Any:
        ...
    
    def __contains__(self, key: Any) -> bool:
        ...
    
    def __iter__(self) -> Any:
        ...
    
    def __float__(self) -> str:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    @staticmethod
    def read_from_stream(stream: StreamType, pdf: Any) -> IndirectObject:
        ...
    


FLOAT_WRITE_PRECISION = ...
class FloatObject(float, PdfObject):
    def __new__(cls, value: Any = ..., context: Optional[Any] = ...) -> FloatObject:
        ...
    
    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> FloatObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def myrepr(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def as_numeric(self) -> float:
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    


class NumberObject(int, PdfObject):
    NumberPattern = ...
    def __new__(cls, value: Any) -> NumberObject:
        ...
    
    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> NumberObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def as_numeric(self) -> int:
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    @staticmethod
    def read_from_stream(stream: StreamType) -> Union[NumberObject, FloatObject]:
        ...
    


class ByteStringObject(bytes, PdfObject):
    """
    Represents a string object where the text encoding could not be determined.

    This occurs quite often, as the PDF spec doesn't provide an alternate way to
    represent strings -- for example, the encryption data stored in files (like
    /O) is clearly not text, but is still stored in a "String" object.
    """
    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> ByteStringObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    @property
    def original_bytes(self) -> bytes:
        """For compatibility with TextStringObject.original_bytes."""
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class TextStringObject(str, PdfObject):
    """
    A string object that has been decoded into a real unicode string.

    If read from a PDF document, this string appeared to match the
    PDFDocEncoding, or contained a UTF-16BE BOM mark to cause UTF-16 decoding
    to occur.
    """
    autodetect_pdfdocencoding: bool
    autodetect_utf16: bool
    utf16_bom: bytes
    _original_bytes: Optional[bytes] = ...
    def __new__(cls, value: Any) -> TextStringObject:
        ...
    
    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> TextStringObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    @property
    def original_bytes(self) -> bytes:
        """
        It is occasionally possible that a text string object gets created where
        a byte string object was expected due to the autodetection mechanism --
        if that occurs, this "original_bytes" property can be used to
        back-calculate what the original encoded bytes were.
        """
        ...
    
    def get_original_bytes(self) -> bytes:
        ...
    
    def get_encoded_bytes(self) -> bytes:
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    


class NameObject(str, PdfObject):
    delimiter_pattern = ...
    prefix = ...
    renumber_table: ClassVar[Dict[str, bytes]] = ...
    def clone(self, pdf_dest: Any, force_duplicate: bool = ..., ignore_fields: Optional[Sequence[Union[str, int]]] = ...) -> NameObject:
        """Clone object into pdf_dest."""
        ...
    
    def hash_bin(self) -> int:
        """
        Used to detect modified object.

        Returns:
            Hash considering type and value.

        """
        ...
    
    def write_to_stream(self, stream: StreamType, encryption_key: Union[None, str, bytes] = ...) -> None:
        ...
    
    def renumber(self) -> bytes:
        ...
    
    @classproperty
    def surfix(cls) -> bytes:
        ...
    
    @staticmethod
    def unnumber(sin: bytes) -> bytes:
        ...
    
    CHARSETS = ...
    @staticmethod
    def read_from_stream(stream: StreamType, pdf: Any) -> NameObject:
        ...
    


def encode_pdfdocencoding(unicode_string: str) -> bytes:
    ...

def is_null_or_none(x: Any) -> TypeGuard[Union[None, NullObject, IndirectObject]]:
    """
    Returns:
        True if x is None or NullObject.

    """
    ...

